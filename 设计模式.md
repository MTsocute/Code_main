# 设计模式

---

- UML

## 1. UML 简要介绍

---

### 1. UML 单独的类的表示

> 单独的一个类抽象出来的图

```cpp
class Hunter
{
public:
    int m_age = 32;
    static int m_times;
    string getName()
    {
        return m_name;
    }

    void setName(string name)
    {
        m_name = name;
    }

    void goHunting()
    {
        aiming();
        shoot();
    }
    static void saySorry()
    {
        string count = to_string(m_times);
        cout << "Say sorry to every animal " + count + " times!" << endl;
    }

protected:
    string m_name = "Jack";
    void aiming()
    {
        cout << "使用" + m_gunName + "瞄准猎物..." << endl;
    }

private:
    string m_gunName = "AK-47";
    void shoot()
    {
        cout << "使用" + m_gunName + "射击猎物..." << endl;
    }
};
```

> 抽象的图
>
> **可见性：+ 表示 public、# 表示 protected、- 表示 private、__(下划线)表示 static**

![image-20250407170540237](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250407170540237.png)

### 2. UML 之间的关系

> 虚函数是

<br>

## 2. 类

----

> 对象编程（OOP）中的三个基本特性之一（封装、继承、多态）
>
> ![image-20250328121335261](https://raw.githubusercontent.com/MTsocute/New_Image/main/img/image-20250328121335261.png)

### 2.1 delete 禁止某些成员函数

> `delete` 关键字不仅仅限制在**操作符函数**上，也可以用来删除任何**特殊成员函数**，包括普通成员函数

```c++
class MyClass {
public:
    MyClass() = default;
    
    // 禁止拷贝构造
    MyClass(const MyClass&) = delete;
    
    // 禁止赋值操作符
    MyClass& operator=(const MyClass&) = delete;
};
```

> 删除**特殊成员函数**

```c++
class MyClass {
public:
    void doSomething(int) = delete;   // 禁止带有 int 参数的 doSomething 函数
    void doSomething(double) {}       // 允许带有 double 参数的 doSomething 函数
};
```

> 禁止**拷贝和移动构造一个新的类**

```cpp
TCP_Server(const TCP_Server &other) = delete;
TCP_Server operator=(const TCP_Server &other) = delete;
TCP_Server(TCP_Server&&) = delete;  // 禁止移动构造
TCP_Server& operator=(TCP_Server&&) = delete;  // 禁止移动赋值
```

### 2.2 类的静态成员函数

> #### 什么时候使用静态成员函数？
>
> - **无状态操作**：如果函数执行的操作与特定对象无关，不需要访问对象的成员变量或非静态成员函数，那么它可以被声明为静态函数。

```c++
class MathUtils {
public:
    // 静态成员函数，可以在不实例化对象的情况下调用
    static int add(int a, int b) {
        return a + b;
    }

    // 非静态函数，需要对象实例才能调用
    int multiply(int a, int b) {
        return a * b * rd;
    }
private:
    int rd = rand() % 100;
};

int main() {
    // 调用静态成员函数，不需要创建 MathUtils 的实例
    std::cout << "3 + 4 = " << MathUtils::add(3, 4) << std::endl;

    // 需要创建对象才能调用非静态成员函数
    MathUtils utils;
    std::cout << "3 * 4 = " << utils.multiply(3, 4) << std::endl;

    return 0;
}
```

> 类内静态函数是独一份，不论生成了多少个类，公用的都是同一个
>
> 下面这个案例，你会发现输出地址都是一样的

```c++
class Demo {
public:
    // 静态成员函数
    static constexpr int add(int a, int b) { return a + b; }

    // 输出 add 函数的地址
    void printAddAddress() {
        std::cout << "Address of add from instance: " << 
            reinterpret_cast<void*>(&Demo::add) << std::endl;
    }
};

int main() {
    Demo demo1;
    Demo demo2;

    // 比较地址
    demo1.printAddAddress();
    demo2.printAddAddress();

    // 直接获取静态函数地址
    std::cout << "Address from Demo::add: " <<
        reinterpret_cast<void*>(&Demo::add) << std::endl;

    return 0;
}

```

### 2.3 explicit

> 避免隐式的生成一个类

```c++
class MyClass {
public:
    // 没有 explicit 的构造函数
    MyClass(int x) {
        std::cout << "MyClass constructor called with x = " << x << std::endl;
    }
};

int main() {
    MyClass obj = 42; // 隐式调用构造函数
}
```

<br>

### 2.4 类的类型转换

---

#### 2.4.1 向上转换

```c++
// 基类和派生类之间的转换（向上转换）
class Base {
public:
    virtual void show() { cout << "Base class" << endl; }
};

class Derived : public Base {
public:
    void show() { cout << "Derived class" << endl; }
};

Derived derivedObj;
// Derived* -> Base*: 派生转换基类
Base* basePtr = static_cast<Base*>(&derivedObj);  
// 使用派生对象转换基类，使用基类的方法
basePtr->show();
```

```c++
Base* base = new Derived();

// 基类指针到派生类指针的转换
Derived* derived = dynamic_cast<Derived*>(base);

if (derived) {
    cout << "dynamic_cast 成功: ";
    derived->show();
} 
else cout << "dynamic_cast 失败" << endl;

delete base;
```

#### 2.4.2 向下转换

> `dynamic_cast` 主要用于具有虚函数的多态类型的指针或引用之间的转换，尤其适用于**基类和派生类之间的安全向下转换**。
>
> 如果转换失败，指针会返回 `nullptr`，引用则抛出异常

```c++
// 非多态类型的转换示例
Base* nonPolymorphic = new Base();
// 基类转换到派生类（向下转换）
derived = dynamic_cast<Derived*>(nonPolymorphic);

if (derived) derived->show();
else cout << "dynamic_cast 对非多态类型转换失败" << endl;
delete nonPolymorphic;
```

### 2.5 有元函数

> 友元函数可以访问类中的私有数据和方法，这样可以在不暴露这些成员的情况下提供特定功能。
>
> 但是是要把类对象作为参数导入的时候哈

```c++
class MyClass; // 前向声明

class FriendClass {
public:
    void display(MyClass &obj); // 声明友元函数
};

class MyClass {
private:
    int value;

public:
    MyClass(int val) : value(val) {}

    // 声明 FriendClass 为友元
    friend class FriendClass; 
};

void FriendClass::display(MyClass &obj) {
    cout << "MyClass 的私有值: " << obj.value << endl; // 访问私有成员
}

int main() {
    MyClass myObj(42);
    FriendClass friendObj;
    friendObj.display(myObj); // 调用友元函数

    return 0;
}
```



### 2.6 `virtual`

---

#### 1. 基本概念

> 虚函数的关键点是**动态绑定**（也叫运行时绑定）。
>
> 在没有 `virtual` 的情况下，C++ 的函数调用是**静态绑定**（也叫编译时绑定），即编译器在编译时就确定了调用哪个函数。而 `virtual` 会告诉编译器，**函数调用要在运行时根据对象的实际类型来确定**

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void foo() {
        cout << "Base foo" << endl;
    }
};

class Derived : public Base {
public:
    void foo() override {  // 重写基类的虚函数
        cout << "Derived foo" << endl;
    }
};

int main() {
    Base* basePtr = new Derived();  // 基类指针指向派生类对象
    Base& baseRef = *basePtr;  // 基类引用指向派生类对象

    basePtr->foo();  // 通过基类指针调用虚函数，调用 Derived 中的 foo()
    baseRef.foo();   // 通过基类引用调用虚函数，调用 Derived 中的 foo()

    delete basePtr;
    return 0;
}
```

#### 2. 虚函数的规则

> **必须通过指针或引用调用**：如果直接通过对象调用，仍然是静态绑定。

```cpp
Base* basePtr = new Derived();  // 基类指针指向派生类对象
Base& baseRef = *basePtr;  // 基类引用指向派生类对象

basePtr->foo();  // 通过基类指针调用虚函数，调用 Derived 中的 foo()
baseRef.foo();   // 通过基类引用调用虚函数，调用 Derived 中的 foo()
```

> **重写时函数签名必须一致**：
>
> - 参数和返回值类型必须匹配。
> - 可以使用 `override` 关键字来明确地表明重写行为。
>
> ```cpp
> void display() override;  // 推荐使用
> ```
>
> **虚函数只能存在于类中**：全局函数不能声明为虚函数

```cpp
void display() override;  // 推荐使用
```

> **如果一个类有虚函数，其析构函数通常也应声明为虚函数**：避免通过基类指针删除派生类对象时资源释放不完全的问题。

```cpp
class Base {
public:
    // 析构函数声明为虚类
    virtual ~Base() { std::cout << "Base destroyed\n"; }
};

class Derived : public Base {
public:
    ~Derived() { std::cout << "Derived destroyed\n"; }
};
```

#### 3. 纯虚函数

> 如果一个类中的虚函数不需要具体实现，可以声明为 **纯虚函数**，用 `= 0` 表示
>
> 带有纯虚函数的类是**抽象类**，不能直接实例化。它通常用作接口，让派生类实现特定功能。
>
> 继承了带有纯虚函数的类, 必须重写纯虚函数

```cpp
class Payment {
public:
    virtual void process() = 0;  // 纯虚函数，提供统一接口
};

class CreditCard : public Payment {
public:
    void process() override {
        cout << "Processing credit card payment" << endl;
    }
};

class PayPal : public Payment {
public:
    void process() override {
        cout << "Processing PayPal payment" << endl;
    }
};

// 客户端代码
void checkout(Payment* payment)	// 动态绑定 
{
    payment->process();  // 统一调用接口
}

int main() {
    CreditCard cc;
    PayPal pp;

    checkout(&cc);  // 输出：Processing credit card payment
    checkout(&pp);  // 输出：Processing PayPal payment
    return 0;
}
```

### 2.7 类成员函数 const 

> 我们的成员函数是可以访问类的成员变量，有了这个 const 声明的成员函数是不可以修改类变量的

```cpp
class Client : public QWidget {
public:
    explicit Client(QWidget *parent = nullptr);
    ~Client() override;

private slots:
    // 你会发现所有的成员函数的后面都有 const
    void clicked_on_connect_button() const;
    void open_chat_box() const;

private:
    Ui::Client *ui;
    Form *chat;
    QTcpSocket *socket;
};
```

### 2.8 父类的没有默认构造的继承注意事项

> 在 C++ 中，如果一个子类继承了一个父类，**并且父类没有默认构造函数（即只有带参的构造函数）**，那么子类的构造函数确实需要显式地调用父类的构造函数并传递适当的参数。

```cpp
class Parent {
public:
    Parent(int x) { 
        // 带参数的构造函数
    }
};

class Child : public Parent {
public:
    // 在实现自己构造的同时并需要实现父类的默认构造函数
    Child(int x) : Parent(x) {  // 必须显式调用父类构造函数并传递参数
        // 子类的构造函数
    }
};
```

> 所以 `QT` 很多的时候都一个 `parent` 参数, 因为其父类构造需要一个 `Qwidget * parent`

```cpp
// 继承于 QMainWindow 所以要实现其父类的构造函数传入 parent
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow) {
    ui->setupUi(this);
	...
}
```

### $\textcolor{pink}{2.9 构造/析构 在不同访问权限下的影响}$

> 在 C++ 中，构造函数和析构函数的访问权限（`public`、`protected`、`private`）决定了**谁能创建或销毁对象**。
>
> ### **访问权限的影响：**
>
> - `public` 构造/析构函数：
>   - **任何地方**都可以创建或销毁对象。
> - `protected` 构造/析构函数：
>   - **类内部和子类**可以创建或销毁对象，但类外部无法直接创建或销毁。
> - `private` 构造/析构函数：
>   - **只有类自身**可以创建或销毁对象，**外部和子类都无法直接创建或销毁对象**。
>

#### 1. **`protected` 构造函数**（子类可以创建，但类外不能）

```cpp
class A {
protected:
    A() { cout << "A 的构造函数" << endl; }
};

class B : public A {
public:
    B() { cout << "B 的构造函数" << endl; }
};

int main() {
    // A a;  // 错误，无法直接创建 A 的对象
    B b;  // 但是可以通过子类 B 创建 --> 这个时候 A 也会跟着构造, 其实是可以用 A 的
    return 0;
}
```

> 结果

```shell
A 的构造函数
B 的构造函数
A 的构造函数
```



#### 2. **`private` 构造函数**（无法创建对象，只能内部创建）

> 常用于单例模式，确保创建的对象唯一的手段
>
> `private` 构造/析构函数：外部完全不能创建或销毁对象，常用于**单例模式**或**工厂方法**模式

```cpp
class A {
private:
    A() { cout << "A 的构造函数" << endl; }

public:
    static A create() {  // 提供静态函数间接创建对象
        return A();
    }
};

int main() {
    // A obj;  // 错误，无法直接创建 A
    A obj = A::create();  // 可以通过静态函数创建
    return 0;
}
```

#### 3. `private` 析构函数

> 常用于单例模式或禁止外部删除对象
>
> **析构函数设为 `private` 时，要小心内存泄漏问题**，需要提供类内部的释放机制（例如静态方法）
>
> **热知识**: 析构函数清除的是内部存储的指针对象, 而不是指针指向的对象, 所以内部开辟的空间一要好好管理, 别人传过来的指针, 除非他不处理, 不然你也别手动清理

```cpp
class A {
private:
    ~A() { cout << "A 的析构函数" << endl; }

public:
    static A* create() { return new A(); }
};

int main() {
    A* obj = A::create();
    // delete obj;  // 错误！析构函数是 private，无法 delete
    return 0;
}
```

<br>
